次版渣代码的一些说明
==============================

在设计模式中有一个论断，几乎一切因为技术水平而难以完成的任务，都可以通过增加
中间层来解决。然后我这个渣渣，通过加到四个中间层的方式，终于写出了一个还能看
的程序来。

建立索引的过程可以用map-reduce模型很好地描述。首先，将对象map成key-value的形
式(MCM)，然后将key-value「倒排」成value-key的结构(MCM_2)。然而，这样得到的结
构是非常松散的，所以还需要进一步的reduce，分块归并成紧凑而易于处理的结构(MCM_2, 
MCM_3, MCM_4)。最后，使用已经reduce的结构，进行快速的查找(MCM_5)。

对于每个中间层具体的操作和数据结构，记录在了各程序文件夹的ReadMe.md文档里面。
关于各中间层的文件的关系，画在了Illustration图片里。由于现在程序还需要进一步
的重构，你萌可以只看这些readMe文档，不用去翻我的(明显过于长的)源码。

现在这个程序在10000的testCase下通过了正确性测试，速度也达到了一定的要求。但是
还有以下几点需要日后我review整改，按照重要程度先后排列：

1.当待查k-Mer为TTTTT时，会返回No Result。

2.MCM_4生成的bisearchTable文件中的第二个数组，直接记录了数据块的物理位置，数
值较大，容易超出类型范围，可以考虑记录数据块编号，然后在查询时换算为物理位置。

3.当k增大时，kMerOrder的种类数会成指数增长，很快超过类型范围。当初是因为自己
姿势水平太低，对Hash表不熟悉，偷懒直接用四进制数表达kMerOrder。而要让程序适用
范围更广，加入Hash表是势在必行的事情。

4.在Coding style方面，文件、函数、变量命名不统一，一些危险的函数也没有进行有
效的保护，层次划分不够清晰。对于不同层次的公共部分，没有做成公共的头文件，未
日后不同层次的合并带来了隐患。

5.各个中间层的readME文档内容不够完善，很多细节没有解释清楚，需要进一步写一写。

5.现在已经凌晨1:53了好困啊电脑快要没电了还突然觉得特别饿坐了好久腰好疼糟糕明
天物理还要期中考试但是我一点都没复习怎么办怎么办似乎也没什么办法了本来应该再
深入多写一些document的但是既然这么晚了就先这样吧T_T

6.张翔熙

~~~~~~~~~~~~~~~~~~~~~~~~4/24 UPDATE~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

搞定的问题有：

1.解决了TTTTT的BUG，BUG原因是MCM_4在读取数组长度的时候没有进行增一操作。

2.将Shell排序改换成计数排序，排序时间进一步加快，而且还解决了输出序列乱序的问
题。

还需要解决的问题有：

1.bisearchTable的第二个数组，原本存储为数据块的物理位置，可以考虑改为存储数据
块编号，然后在寻址时换算为物理地址。这个问题改完之后可以考虑改换100000的testCase。

2.引入Hash表不可避。

3.Coding style的部分还是要慢慢review的，中间层的组织也需要整改啊。通过1000000
的testCase之后就可以考虑整合成一个大程序了，可以提前设计不同部分的通信控制。

4.在这里偷偷膜一下沅神反正又不会被看到~

张翔熙

~~~~~~~~~~~~~~~~~~~~~~~~~4/25 UPDATE~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

搞定了数据块存储位置超出int范围的问题，可以试一试更大的testCase了。

更改了缓冲区的大小，解决了之前MCM_3的性能瓶颈。

现在可以轻松搞定k=8时1,000,000的testCase。

还需要解决的问题有：

1.解决k值更大的时候的kMer序号存储的问题。考虑到Hash表也有数据类型溢出的问题，可能
需要另外的数据结构来存储kMer的序号。

2.这个文档也需要重构一下，现在解释性还是不强，只能作为自己看的update log来使用。

3.修改解决五个程序之间的冲突，设计好用来通信的接口，为下一步的整合做提前的准备。

张翔熙

~~~~~~~~~~~~~~~~~~~~~~~~~4/27 UPDATE~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我是个大傻蛋...MCM_3的计数排序的过程就直接生成了我要的列表...根本不需要MCM_4的转换。

准备把第四层去掉，直接生成第五层所需的文件。